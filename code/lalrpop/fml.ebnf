(* FML syntax
 * 
 * A more ML-like syntax for the Feeny toy language.
 * Based loosely on the EBNF from https://caml.inria.fr/pub/docs/manual-ocaml/
 *
 *)

(* The following characters are considered as blanks. Blanks are ignored, but
 * they separate adjacent identifiers, literals and keywords that would 
 * otherwise be confused as one single identifier, literal or keyword.
blanks ::= ' ' | '\t' | '\n' | '\r';

commen ::= ? \(\*.*\)\* ? (* ML-style comments*)

(* various simple tokens *)
letter ::= 'A' .. 'Z' âˆ£  'a' .. 'z';
digit  ::= '0' .. '9';
underscore ::= '_';
regular_character ::= ? [^/] ?;
escape_sequence ::= '\' ('"' | "'" | 'n' | 't' | 'b' | 'r' | ' ');
double_quote ::= '"';
lparen ::= "(";
rparen ::= ")";
lbracket ::= "[";
rbracket ::= "]";
semicolon ::= ";"
dot ::= ".";
larrow ::= "<-"
rarrow ::= "->"

(* operators *)
plus ::= "+";
multiply ::= "*";
divide ::= "/";
lesser ::= "<"
lesser_or_equal ::= "<="
greater ::= ">"
greater_or_equal ::= ">="
or ::= "|"
and ::= "&"
minus  ::= '-';
equal ::= "="

(* keywords *)
while ::= "while"
object ::= "object"
if ::= "if"
else  ::= "else"
then ::= "then"
true ::= "true";
false ::= "false";
array ::= "array";
unit ::= "null";
let ::= "let";
begin ::= "begin";
end ::= "end";
this ::= "this";

(* identifiers *)
identifier ::= (letter | underscore) {letter | digit | underscore} | this;
operator ::= multiply | plus | minus | "!=" | equal | lesser | greater | lesser_or_equal | greater_or_equal | or | and;
method_identifier ::= identifier | operator;

(* literals *)
literal ::= number | string | boolean | unit | begin end;                                   (* begin end == unit *)
number ::= [minus] {digit};
string ::= double_quote {string_element} double_quote;
string_element ::= regular_character | escape_sequence;
boolean ::= true | false;                                                                   (* still thinking about it *)

(* the big expression machine *)
expression ::= lparen expression rparen                                                     (* expression in parentheses *)
             | begin expression {semicolon expression} end                                  (* expression block *)

             | function identifier parameter_list rarrow expression                         (* Feeny-style function definition, returns unit? *)
             | expression argument_list                                                     (* function application *)

             | object parameter_list begin object_body end                                  (* prototype object definition *)
             | expression dot identifier                                                    (* field access *)
             | expression dot identifier larrow expression                                  (* field mutation *) 
             | expression dot method_identifier argument_list                               (* method call *)

             | array lbracket expression rbracket                                           (* array definition (argument is array size) *)
             | expression lbracket expression rbracket                                      (* array access *)
             | expression lbracket expression rbracket larrow expression                    (* array mutation *)

             | if expression then expression [else expression]                              (* conditional expression *)
             | while expression begin expression end                                        (* loop expression *)

             | let identifier equal expression                                              (* Feeny-style variable definition *)        
             | identifier                                                                   (* variable access *)
             | identifier larrow expression                                                 (* variable mutation *)

             | print argument_list                                                          (* call to the print built-in *)                                        
             | expression operator expression                                               (* infix operators, syntactic sugar for method calls *)
             | literal;

parameter_list ::= lparen [identifier {comma identifier} {comma}] rparen;                   (* ommit commas, or have extra trailing commas *)
argument_list ::= lparen [expression {comma expression} {comma}] rparen;

(* A note on function definition. 
 * 
 * In ML a function is anonymous, and a `function x -> x+1` statement returns a
 * function object. This object can be returns out of a scope.
 * 
 * In Feeny, a function is named. A definition statement returns `null` and
 * registers the function with the scope. When the function goes out of scope,
 * it disappears.
 *
 * I think we could probably do ML-style function, if we keep the scoping rules
 * for Feeny, but I did Feeny style functions for now.
 *)

body ::= let identifier equal expression                                                    (* field definition (same as variables) *)
       | function identifier parameter_list rarrow expression;                              (* method definition (same as functions) *)

