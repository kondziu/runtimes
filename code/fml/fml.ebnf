/* FML syntax
 * 
 * A more ML-like syntax for the Feeny toy language.
 * Based loosely on the EBNF from https://caml.inria.fr/pub/docs/manual-ocaml/
 *
 */
toplevel            ::= expression {";" expression} [";"];

/* The following characters are considered as blanks. Blanks are ignored, but
 * they separate adjacent identifiers, literals and keywords that would 
 * otherwise be confused as one single identifier, literal or keyword. 
 */
blanks              ::= 'regexp:[ \t\r\n]';
comment             ::= 'regexp:\(\*([^\)][^\*])*\)\*'; /* ML-style comments*/

/* various simple tokens */
letter              ::= 'regexp:[A-Za-z]';
digit               ::= 'regexp:[0-9]';
underscore          ::= '_';
regular_character   ::= 'regexp:[^/"]';
escape_sequence     ::= 'regexp:\\["ntbr\\]';
double_quote        ::= '"';
lparen              ::= "(";
rparen              ::= ")";
lbracket            ::= "[";
rbracket            ::= "]";
semicolon           ::= ";"
dot                 ::= ".";
comma               ::= ",";
larrow              ::= "<-";
rarrow              ::= "->";
be                  ::= "=";

/* operators */
plus                ::= "+";
multiply            ::= "*";
divide              ::= "/";
module              ::= "%";
lesser_or_equal     ::= "<=";
greater_or_equal    ::= ">=";
lesser              ::= "<";
greater             ::= ">";
or                  ::= "|";
and                 ::= "&";
minus               ::= '-';
equal               ::= "==";
unequal             ::= "!=";

/* keywords */
while               ::= "while";
object              ::= "object";
if                  ::= "if";
else                ::= "else";
then                ::= "then";
true                ::= "true";
false               ::= "false";
array               ::= "array";
unit                ::= "null";
let                 ::= "let";
begin               ::= "begin";
end                 ::= "end";
this                ::= "this";
print               ::= "print";
function            ::= "function";
do                  ::= "do";
extends             ::= "extends";

/* identifiers */
identifier          ::= (letter | underscore)
                        {letter | digit | underscore} | this;
operator            ::= multiply | plus
                      | minus | divide | module
                      | unequal | equal | lesser | greater
                      | lesser_or_equal | greater_or_equal
                      | or | and;
method_id           ::= identifier | operator;

/* operator precedence:
 *     multiply, divide
 *   < plus, minus
 *   < equal, unequal
 *   < lesser, greater, lesser equal, greater equal
 *   < or
 *   < and
 */

/* literals */
literal             ::= number | boolean | unit | begin end;                       /* begin end == unit */
number              ::= [minus] {digit};
boolean             ::= true | false;                                              /* still thinking about it */

/* the big expression machine */
expression          ::= function identifier lparen parameter_list rparen
                        rarrow expression                                          /* Feeny-style function definition,
                                                                                      returns unit? */
                      | object parameter_list [extends expression]                 /* prototype object definition */
                        begin object_body end
                      | field                                                      /* field access */
                      | field larrow expression                                    /* field mutation */
                      | method argument_list                                       /* method call */
                      | accessible lbracket expression rbracket larrow expression  /* array mutation */
                      | if expression then expression [else expression]            /* conditional expression */
                      | while expression do expression                             /* loop expression */
                      | let identifier be expression                               /* Feeny-style variable definition */
                      | identifier larrow expression                               /* variable mutation */
                      | print lparen string [comma argument_list] rparen           /* call to the print built-in */
                      | expression operator expression                             /* infix operators, syntactic sugar
                                                                                      for method calls */
                      | accessible;

accessible          ::= lparen expression rparen                                   /* expression in parentheses */
                      | begin expression {semicolon expression} end                /* expression block */
                      | (identifier | field) lparen argument_list rparen           /* function/method application */
                      | array lparen expression comma expression rparen            /* array definition (arguments are
                                                                                      array size and initial value) */
                      | expression lbracket expression rbracket                    /* array access */
                      | identifier                                                 /* variable access */
                      | literal;

field               ::= accessible dot {identifier dot} identifier;                /* object field path */
method              ::= accessible dot {identifier dot} method_id;                 /* object method path */
parameter_list      ::= [identifier {comma identifier} [comma]];                   /* you can have an extra trailing
                                                                                      comma */
argument_list       ::= [expression {comma expression} [comma]];
object_body         ::= [member {semicolon member} [semicolon]];                   /* contents of an object definition*/
member              ::= let identifier equal expression                            /* field definition (same as
                                                                                      variables) */
                      | function identifier lparen parameter_list rparen
                        rarrow expression;                                         /* method definition (same as
                                                                                      functions) */
string              ::= double_quote {(regular_character | escape_sequence)}
                        double_quote;                                              /* string literals for use in print
                                                                                      (and nowhere else)*/

/* A note on function definition.
 * 
 * In ML a function is anonymous, and a `function x -> x+1` statement returns a
 * function object. This object can be returns out of a scope.
 * 
 * In Feeny, a function is named. A definition statement returns `null` and
 * registers the function with the scope. When the function goes out of scope,
 * it disappears.
 *
 * I think we could probably do ML-style function, if we keep the scoping rules
 * for Feeny, but I did Feeny style functions for now.
 */

