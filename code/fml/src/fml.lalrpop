use std::str::FromStr;
use std::collections::VecDeque;
use crate::fml_ast::AST;
use crate::fml_ast::Operator;

grammar;

// Lexer
match {
    r"\s*" => { }, // ignore whitespace
    r"\(\*([^\*]*\*+[^\*\(])*([^\*]*\*+|[^\*])*\*\)" => { }, // ignore

    // all keywords and fixed tokens
    ";" => SEMICOLON,
    "begin" => BEGIN,
    "end" => END,
    "|" => OR,
    "&" => AND,
    "==" => EQUAL,
    "!=" => UNEQUAL,
    ">" => GREATER,
    "<" => LESS,
    ">=" => GREATER_EQUAL,
    "<=" => LESS_EQUAL,
    "+" => PLUS,
    "-" => MINUS,
    "/" => DIVIDE,
    "*" => MULTIPLY,
    "%" => MODULE,
    "if" => IF,
    "then" => THEN,
    "else" => ELSE,
    "(" => LPAREN,
    ")" => RPAREN,
    "let" => LET,
    "=" => BE,
    "null" => UNIT,
    "<-" => LARROW,
    "->" => RARROW,
    "print" => PRINT,
    "object" => OBJECT,
    "extends" => EXTENDS,
    "." => DOT,
    "[" => LBRACKET,
    "]" => RBRACKET,
    "while" => WHILE,
    "do" => DO,
    "function" => FUNCTION,
    "array" => ARRAY,
    "," => COMMA,
    "true" => TRUE,
    "false" => FALSE,
    "this" => THIS,

    // all fungible tokens
    r"[_A-Za-z][_A-Za-z0-9]*" => IDENTIFIER,
    r"[-]?[0-9]+" => NUMBER,
    r#""([^\\]|\\[ntbr\\])*""# => STRING_LITERAL,
}

// Parser

pub TopLevel: AST<'input> = {
    <expressions: Expressions> => expressions,
                               => AST::Unit,
}

Expressions: AST<'input> = {
    <element: Expression<"open">> <elements: (SEMICOLON <Expression<"open">>)*> SEMICOLON? => {
        if elements.is_empty() {
            element
        } else {
            let mut all = VecDeque::from(elements);
            all.push_front(element);
            AST::Block(put_into_boxes!(Vec::from(all)))
        }
    }
}

Expression<openness>: AST<'input> = {
    FunctionDefinition<openness>      => <>, // Feeny-style function definition, returns unit?
    ObjectDefinition                  => <>, // prototype object definition
    Assignment<openness>              => <>, // Feenified variable definition
    Field                             => <>, // field access
    Conditional<openness>             => <>, // conditional expression
    Loop<openness>                    => <>, // loop expression
    Mutation<openness>                => <>, // variable/object member mutation
    Print                             => <>, // call to the print built-in
    Operation                         => <>, // operations, but this also leads to Accessible
}


Block: AST<'input> = {
    BEGIN END                            => AST::Unit,
    BEGIN <expressions: Expressions> END => expressions
}

Accessible: AST<'input> = {
    ParenthesizedExpression           => <>, // expression in parentheses
    Block                             => <>, // expression block
    Application                       => <>, // function application
    ArrayDefinition                   => <>, // array definition
    ArrayAccess                       => <>, // array access
    Identifier                        => <>, // variable access
    Literal                           => <>, // literal, duh
}

Operation: AST<'input> = {
    Disjunction             => <> // Let's climb the operator precedence!
}

Disjunction: AST<'input> = {
    <head: Conjunction> <tail: (<DisjunctionOperator> <Conjunction>)*> =>
        make_operator_ast!(head, tail)
}

Conjunction: AST<'input> = {
    <head: Comparison> <tail: (<ConjunctionOperator> <Comparison>)*> =>
        make_operator_ast!(head, tail)
}

Comparison: AST<'input> = {
    <head: Additive> <tail: (<EqualityOperator> <Additive>)*> =>
        make_operator_ast!(head, tail)
}

Additive: AST<'input> = {
    <head: Factor> <tail: (<AdditiveOperator> <Factor>)*> =>
        make_operator_ast!(head, tail)
}

Factor: AST<'input> = {
    <head: Accessible> <tail: (<FactorOperator> <Accessible>)*> =>
        make_operator_ast!(head, tail)
}

Operator: Operator = {
    ConjunctionOperator => <>,
    DisjunctionOperator => <>,
    EqualityOperator    => <>,
    AdditiveOperator    => <>,
    FactorOperator      => <>,
}

ConjunctionOperator: Operator = {
    AND => Operator::Conjunction,
}

DisjunctionOperator: Operator = {
    OR => Operator::Disjunction,
}

EqualityOperator: Operator = {
    EQUAL => Operator::Equality,
    UNEQUAL => Operator::Inequality,
    GREATER  => Operator::Greater,
    GREATER_EQUAL => Operator::GreaterEqual,
    LESS => Operator::Less,
    LESS_EQUAL => Operator::LessEqual,
}

AdditiveOperator: Operator = {
    PLUS => Operator::Addition,
    MINUS => Operator::Subtraction,
}

FactorOperator: Operator = {
    MULTIPLY => Operator::Multiplication,
    DIVIDE => Operator::Division,
    MODULE => Operator::Module,
}

Literal: AST<'input> = {
    Number                  => <>,
    Boolean                 => <>,
    Unit                    => <>,
}

ParenthesizedExpression: AST<'input> = {
    LPAREN <Expression<"open">> RPAREN    => <>
}

Member: AST<'input> = {
    Assignment<"open">         => <>,
    FunctionDefinition<"open"> => <>,
    OperatorDefinition<"open"> => <>,
}

Conditional<openness>: AST<'input> = {
    IF <condition: Expression<"open">> THEN <consequent: Expression<"closed">>
                                       ELSE <alternative: Expression<openness>> =>
        AST::Conditional{condition: Box::new(condition),
                         consequent: Box::new(consequent),
                         alternative: Box::new(alternative)},
    IF <condition: Expression<"open">> THEN <consequent: Expression<"open">> if openness == "open" =>
        AST::Conditional{condition: Box::new(condition),
                         consequent: Box::new(consequent),
                         alternative: Box::new(AST::Unit)},
}

Print: AST<'input> = { // TODO format string check
    PRINT LPAREN <string: String> <arguments: (COMMA <Arguments>)?> RPAREN => {
        let boxed_arguments: Vec<Box<AST<'input>>> = match arguments {
            Some(arguments) => arguments.into_iter().map( | e | Box::new(e)).collect(),
            None => vec!(),
        };
        AST::Print {format: Box::new(string), arguments: boxed_arguments}
    }
}

ObjectDefinition: AST<'input> = {
    OBJECT <parameters: Parameters> <extends: (EXTENDS <Expression<"open">>)?> <members: Members> =>
        AST::ObjectDefinition {extends: option_into_box!(extends),
                               parameters: put_into_boxes!(parameters),
                               members: put_into_boxes!(members)}
}

Members: Vec<AST<'input>> = {
    BEGIN <elements: (<Member> SEMICOLON)*> <element: Member?> END => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Field: AST<'input> = {
    <object: Accessible> DOT <objects: (<Identifier> DOT)*> <field: Identifier> => {
        let mut tail = Vec::from(objects);
        tail.push(field);
        tail.into_iter().fold(object, |left, right|
            AST::FieldAccess {object: Box::new(left), field: Box::new(right)})
    }
}

Method: AST<'input> = {
    Field => <>,
    <object: Accessible> DOT <objects: (<Identifier> DOT)*> <operator: Operator> => {
        let path = objects.into_iter().fold(object, |left, right|
            AST::FieldAccess {object: Box::new(left), field: Box::new(right)});
        AST::OperatorAccess {object: Box::new(path), operator}
    }
}

ArrayDefinition: AST<'input> = {
    ARRAY LPAREN <size: Expression<"open">> COMMA <value: Expression<"open">> RPAREN =>
        AST::ArrayDefinition {size: Box::new(size), value: Box::new(value)}
}

ArrayAccess: AST<'input> = {
    <array: Accessible> LBRACKET <index: Expression<"open">> RBRACKET =>
        AST::ArrayAccess {array: Box::new(array), index: Box::new(index)},
    <array: Field> LBRACKET <index: Expression<"open">> RBRACKET =>
        AST::ArrayAccess {array: Box::new(array), index: Box::new(index)}
}

Loop<openness>: AST<'input> = {
    WHILE <condition: Expression<"open">> DO <body: Expression<openness>> =>
        AST::Loop{condition: Box::new(condition), body: Box::new(body)}
}

FunctionDefinition<openness>: AST<'input> = {
    FUNCTION <id: Identifier> <parameters: Parameters> LARROW <body: Expression<openness>> =>
        AST::FunctionDefinition{name: Box::new(id),
                                parameters: put_into_boxes!(parameters),
                                body: Box::new(body)}
}

OperatorDefinition<openness>: AST<'input> = {
    FUNCTION <operator: Operator> <parameters: Parameters> LARROW <body: Expression<openness>> =>
        AST::OperatorDefinition{operator: operator,
                                parameters: put_into_boxes!(parameters),
                                body: Box::new(body)}
}

Parameters: Vec<AST<'input>> = {
    LPAREN <elements: (<Identifier> COMMA)*> <element: Identifier?> RPAREN =>
        match element {
            None => elements,
            Some(e) => { let mut elements = elements; elements.push(e); elements }
        }
}

Application: AST<'input> = {
    <function: Identifier> LPAREN <arguments: Arguments> RPAREN => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
            arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::FunctionApplication{function: Box::new(function), arguments: boxed_arguments}
    },
    <method: Method> LPAREN <arguments: Arguments> RPAREN => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
            arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::MethodCall{method_path: Box::new(method), arguments: boxed_arguments}
    },
    <array: ArrayAccess> LPAREN <arguments: Arguments> RPAREN => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
            arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::MethodCall{method_path: Box::new(array), arguments: boxed_arguments}
    }
}

Arguments: Vec<AST<'input>> = {
    <elements: (<Expression<"open">> COMMA)*> <element: Expression<"open">?> => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Assignment<openness>: AST<'input> = {
    LET <id: Identifier> BE <v: Expression<openness>> =>
        AST::Assignment{identifier: Box::new(id), value: Box::new(v)},
}

Mutation<openness>: AST<'input> = {
    <id: Identifier> LARROW <v: Expression<openness>> =>
        AST::Mutation{identifier: Box::new(id), value: Box::new(v)},
    <field: Field> LARROW <v: Expression<openness>> =>
        AST::FieldMutation{field_path: Box::new(field), value: Box::new(v)},
    <array: ArrayAccess> LARROW <v: Expression<openness>> =>
        AST::ArrayMutation {array: Box::new(array), value: Box::new(v)},
}

Identifier: AST<'input> = {
     IDENTIFIER                          => AST::Identifier(<>),
     THIS                                => AST::Identifier(<>),
}

Number: AST<'input> = {
     NUMBER                              => AST::Number(i32::from_str(<>).unwrap()),
}

String: AST<'input> = {
    <s:STRING_LITERAL>                   => AST::StringLiteral(&s[1..s.len()-1]),
}

Boolean: AST<'input> = {
    TRUE                                 => AST::Boolean(true),
    FALSE                                => AST::Boolean(false),
}

Unit: AST<'input> = {
    UNIT                                 => AST::Unit,
}