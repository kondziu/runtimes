use std::str::FromStr;
use crate::fml_ast::AST;

grammar;

pub TopLevel: AST<'input> = {
    Expression                        => <>,
}

Expression: AST<'input> = {
    ParenthesizedExpression               => <>, // expression in parentheses
    Block                                 => <>, // expression block

    FunctionDefinition                    => <>, // Feeny-style function definition, returns unit?
    Application                           => <>, // function/method application

    ObjectDefinition                      => <>, // prototype object definition
    Field                                 => <>, // field access

    ArrayDefinition                       => <>, // array definition (argument is array size and initial value
    ArrayAccess                           => <>, // array access

    Conditional                           => <>, // conditional expression
    Loop                                  => <>, // loop expression

    Assignment                            => <>, // Feenified variable definition
    Identifier                            => <>, // variable/object member access
    Mutation                              => <>, // variable/object member mutation

    Print                                 => <>, // call to the print built-in
    //Operation                           => <>, // infix operators, syntactic sugar to method calls

    Literal                               => <>,
}

ParenthesizedExpression: AST<'input> = {
    "(" <Expression> ")"                  => <>
}

Conditional: AST<'input> = {
    "if" <condition: Expression> "then" <consequent: Expression> <alternative: ("else" <Expression>)> =>
        AST::Conditional{condition: Box::new(condition),
                         consequent: Box::new(consequent),
                         alternative: Box::new(alternative)},
//    "if" <condition: Expression> "then" <consequent: Expression_<"I">> if allow != "" =>
//        AST::Conditional{condition: Box::new(condition),
//                         consequent: Box::new(consequent),
//                         alternative: Box::new(AST::Unit)},
}

Print: AST<'input> = { // TODO format string check
    "print" "(" <string: String> <arguments: ("," <Arguments>)?> ")" => {
        let boxed_arguments: Vec<Box<AST<'input>>> = match arguments {
            Some(arguments) => arguments.into_iter().map( | e | Box::new(e)).collect(),
            None => vec!(),
        };
        AST::Print {format: Box::new(string), arguments: boxed_arguments}
    }
}

ObjectDefinition: AST<'input> = {
    "object" <parameters: Parameters> <members: Members> => {
        let boxed_parameters: Vec<Box<AST<'input>>> =
            parameters.into_iter().map(|e| Box::new(e)).collect();
        let boxed_members: Vec<Box<AST<'input>>> =
            members.into_iter().map(|e| Box::new(e)).collect();
        AST::ObjectDefinition {parameters: boxed_parameters, members: boxed_members}
    }
}

Members: Vec<AST<'input>> = {
    "begin" <elements: (<Member> ";")*> <element: Member?> "end" => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Member: AST<'input> = {
    Assignment         => <>,
    FunctionDefinition => <>,
}

Accessible: AST<'input> = {
    ParenthesizedExpression               => <>, // expression in parentheses
    Block                                 => <>, // expression block
    Application                           => <>, // function application
    ArrayDefinition                       => <>, // array definition
    ArrayAccess                           => <>, // array access
    Identifier                            => <>, // variable access
    Literal                               => <>,
}

Field: AST<'input> = {
    <object: Accessible> "." <objects: (<Identifier> ".")*> <field: Identifier> => {
        let mut it = {
            let mut all = Vec::from(objects);
            all.push(field);
            all.into_iter()
        };

        let mut accumulator = object;
        while let Some(field) = it.next() {
            accumulator = AST::FieldAccess {identifier: Box::new(field),
                                            object: Box::new(accumulator)}
        };

        accumulator
    }
}

ArrayDefinition: AST<'input> = {
    "array" "(" <size: Expression> "," <value: Expression> ")" =>
        AST::ArrayDefinition {size: Box::new(size), value: Box::new(value)}
}

ArrayAccess: AST<'input> = {
    <array: Accessible> "[" <index: Expression> "]" =>
        AST::ArrayAccess {array: Box::new(array), index: Box::new(index)},
    <array: Field> "[" <index: Expression> "]" =>
        AST::ArrayAccess {array: Box::new(array), index: Box::new(index)}
}

Loop: AST<'input> = {
    "while" <condition: Expression> "do" <body: Expression> =>
        AST::Loop{condition: Box::new(condition), body: Box::new(body)}
}

Block: AST<'input> = {
    "begin" <expressions: Expressions> "end" =>
        if expressions.is_empty() {
            AST::Unit
        } else {
            let boxed_expressions: Vec<Box<AST<'input>>> =
                    expressions.into_iter().map(|e| Box::new(e)).collect();
            AST::Block(boxed_expressions)
        }
}

Expressions: Vec<AST<'input>> = {
    <elements: (<Expression> ";")*> <element: Expression?> => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

FunctionDefinition: AST<'input> = {
    "function" <id: Identifier> <parameters: Parameters> "<-" <body: Expression> => {
        let boxed_parameters: Vec<Box<AST<'input>>> =
            parameters.into_iter().map(|e| Box::new(e)).collect();
        AST::FunctionDefinition{identifier: Box::new(id),
                                parameters: boxed_parameters,
                                body: Box::new(body)}
    }
}

Parameters: Vec<AST<'input>> = {
    "(" <elements: (<Identifier> ",")*> <element: Identifier?> ")" => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Application: AST<'input> = {
    <function: Identifier> "(" <arguments: Arguments> ")" => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
            arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::FunctionApplication{identifier: Box::new(function), arguments: boxed_arguments}
    },
    <field: Field> "(" <arguments: Arguments> ")" => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
        arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::MethodCall{field: Box::new(field), arguments: boxed_arguments}
    }
}

Arguments: Vec<AST<'input>> = {
    <elements: (<Expression> ",")*> <element: Expression?> => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Assignment: AST<'input> = {
    "let" <id: Identifier> "=" <v: Expression> =>
        AST::Assignment{identifier: Box::new(id), value: Box::new(v)},
}

Mutation: AST<'input> = {
    <id: Identifier> "<-" <v: Expression> =>
        AST::Mutation{identifier: Box::new(id), value: Box::new(v)},
    <field: Field> "<-" <v: Expression> =>
        AST::FieldMutation{field: Box::new(field), value: Box::new(v)},
    <array: ArrayAccess> "<-" <v: Expression> =>
        AST::ArrayMutation {array: Box::new(array), value: Box::new(v)},
}

Literal: AST<'input> = {
    Number                               => <>,
    String                               => <>, //FIXME remove
    Boolean                              => <>,
    Unit                                 => <>,
}

Identifier: AST<'input> = {
     r"[_A-Za-z][_A-Za-z0-9]*"           => AST::Identifier(<>),
     "this"                              => AST::Identifier(<>),
}

Number: AST<'input> = {
    r"[-]?[0-9]+"                        => AST::Number(i32::from_str(<>).unwrap()),
}

String: AST<'input> = {
    <s:r#""([^\\]|\\[ntbr\\])*""#>       => AST::StringLiteral(&s[1..s.len()-1]),
}

Boolean: AST<'input> = {
    "true"                               => AST::BooleanLiteral(true),
    "false"                              => AST::BooleanLiteral(false),
}

Unit: AST<'input> = {
    "null"                               => AST::Unit,
}

//ExprOperation: AST<'input> = {
//    <left: Expression> <operator: Operator> <right: Expression> =>
//        AST::Operation{operator, left, right}
//}

//Tier<Operator, NextTier>: AST<'input> = {
//    Tier<Op, NextTier> <operator: Operator> NextTier => AST::Operation(operator, Box::new(AST::Unit), Box::new(AST::Unit)),
//    NextTier
//};

//Operator1: Operator = {
//    "+" => Operator::Plus,
//        "-" => Operator::Minus,
//}

//Operator2: Operator = {
//    "*" => Operator::Times,
//    "/" => Operator::Divide,
//}

//    "!=" => Operator::Unequal,
//    "=="  => Operator::Equal,
//    "<"  => Operator::Less,
//    ">"  => Operator::Greater,
//    ">=" => Operator::GreaterEqual,
//    "<=" => Operator::LessEqual,
//    "|"  => Operator::Or,
//    "&"  => Operator::And,