use std::str::FromStr;
use std::collections::VecDeque;
use crate::fml_ast::AST;
use crate::fml_ast::Operator;

grammar;

pub TopLevel: AST<'input> = {
    <expressions: Expressions> => expressions,
                               => AST::Unit,
}

Expressions: AST<'input> = {
    <element: Expression> <elements: (";" <Expression>)*> ";"? => {
        if elements.is_empty() {
            element
        } else {
            let mut all = VecDeque::from(elements);
            all.push_front(element);
            AST::Block(put_into_boxes!(Vec::from(all)))
        }
    }
}

Expression: AST<'input> = {
    FunctionDefinition      => <>, // Feeny-style function definition, returns unit?
    ObjectDefinition        => <>, // prototype object definition
    Field                   => <>, // field access
    Conditional             => <>, // conditional expression
    Loop                    => <>, // loop expression
    Assignment              => <>, // Feenified variable definition
    Mutation                => <>, // variable/object member mutation
    Print                   => <>, // call to the print built-in
    Operation               => <>, // operations, but this also leads to Accessible
}


Block: AST<'input> = {
    "begin" "end"                            => AST::Unit,
    "begin" <expressions: Expressions> "end" => expressions
}

Accessible: AST<'input> = {
    ParenthesizedExpression => <>, // expression in parentheses
    Block                   => <>, // expression block
    Application             => <>, // function application
    ArrayDefinition         => <>, // array definition
    ArrayAccess             => <>, // array access
    Identifier              => <>, // variable access
    Literal                 => <>, // literal, duh
}

Operation: AST<'input> = {
    Disjunction             => <> // Let's climb the operator precedence!
}

Disjunction: AST<'input> = {
    <head: Conjunction> <tail: (<DisjunctionOperator> <Conjunction>)*> =>
        make_operator_ast!(head, tail)
}

Conjunction: AST<'input> = {
    <head: Comparison> <tail: (<ConjunctionOperator> <Comparison>)*> =>
        make_operator_ast!(head, tail)
}

Comparison: AST<'input> = {
    <head: Additive> <tail: (<EqualityOperator> <Additive>)*> =>
        make_operator_ast!(head, tail)
}

Additive: AST<'input> = {
    <head: Factor> <tail: (<AdditiveOperator> <Factor>)*> =>
        make_operator_ast!(head, tail)
}

Factor: AST<'input> = {
    <head: Accessible> <tail: (<FactorOperator> <Accessible>)*> =>
        make_operator_ast!(head, tail)
}

Operator: Operator = {
    ConjunctionOperator => <>,
    DisjunctionOperator => <>,
    EqualityOperator    => <>,
    AdditiveOperator    => <>,
    FactorOperator      => <>,
}

ConjunctionOperator: Operator = {
    "&" => Operator::Conjunction,
}

DisjunctionOperator: Operator = {
    "|" => Operator::Disjunction,
}

EqualityOperator: Operator = {
    "==" => Operator::Equality,
    "!=" => Operator::Inequality,
    ">"  => Operator::Greater,
    ">=" => Operator::GreaterEqual,
    "<"  => Operator::Less,
    "<=" => Operator::LessEqual,
}

AdditiveOperator: Operator = {
    "+" => Operator::Addition,
    "-" => Operator::Subtraction,
}

FactorOperator: Operator = {
    "*" => Operator::Multiplication,
    "/" => Operator::Division,
    "%" => Operator::Module,
}

Literal: AST<'input> = {
    Number                  => <>,
    Boolean                 => <>,
    Unit                    => <>,
}

ParenthesizedExpression: AST<'input> = {
    "(" <Expression> ")"    => <>
}

Member: AST<'input> = {
    Assignment              => <>,
    FunctionDefinition      => <>,
    OperatorDefinition      => <>,
}

Conditional: AST<'input> = {
    "if" <condition: Expression> "then" <consequent: Expression> <alternative: ("else" <Expression>)> =>
        AST::Conditional{condition: Box::new(condition),
                         consequent: Box::new(consequent),
                         alternative: Box::new(alternative)},
//    "if" <condition: Expression> "then" <consequent: Expression_<"I">> if allow != "" =>
//        AST::Conditional{condition: Box::new(condition),
//                         consequent: Box::new(consequent),
//                         alternative: Box::new(AST::Unit)},
}

Print: AST<'input> = { // TODO format string check
    "print" "(" <string: String> <arguments: ("," <Arguments>)?> ")" => {
        let boxed_arguments: Vec<Box<AST<'input>>> = match arguments {
            Some(arguments) => arguments.into_iter().map( | e | Box::new(e)).collect(),
            None => vec!(),
        };
        AST::Print {format: Box::new(string), arguments: boxed_arguments}
    }
}

ObjectDefinition: AST<'input> = {
    "object" <parameters: Parameters> <extends: ("extends" <Expression>)?> <members: Members> =>
        AST::ObjectDefinition {extends: option_into_box!(extends),
                               parameters: put_into_boxes!(parameters),
                               members: put_into_boxes!(members)}
}

Members: Vec<AST<'input>> = {
    "begin" <elements: (<Member> ";")*> <element: Member?> "end" => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Field: AST<'input> = {
    <object: Accessible> "." <objects: (<Identifier> ".")*> <field: Identifier> => {
        let mut tail = Vec::from(objects);
        tail.push(field);
        tail.into_iter().fold(object, |left, right|
            AST::FieldAccess {object: Box::new(left), field: Box::new(right)})
    }
}

ArrayDefinition: AST<'input> = {
    "array" "(" <size: Expression> "," <value: Expression> ")" =>
        AST::ArrayDefinition {size: Box::new(size), value: Box::new(value)}
}

ArrayAccess: AST<'input> = {
    <array: Accessible> "[" <index: Expression> "]" =>
        AST::ArrayAccess {array: Box::new(array), index: Box::new(index)},
    <array: Field> "[" <index: Expression> "]" =>
        AST::ArrayAccess {array: Box::new(array), index: Box::new(index)}
}

Loop: AST<'input> = {
    "while" <condition: Expression> "do" <body: Expression> =>
        AST::Loop{condition: Box::new(condition), body: Box::new(body)}
}

FunctionDefinition: AST<'input> = {
    "function" <id: Identifier> <parameters: Parameters> "<-" <body: Expression> =>
        AST::FunctionDefinition{name: Box::new(id),
                                parameters: put_into_boxes!(parameters),
                                body: Box::new(body)}
}

OperatorDefinition: AST<'input> = {
    "function" <operator: Operator> <parameters: Parameters> "<-" <body: Expression> =>
        AST::OperatorDefinition{operator: operator,
                                parameters: put_into_boxes!(parameters),
                                body: Box::new(body)}
}

Parameters: Vec<AST<'input>> = {
    "(" <elements: (<Identifier> ",")*> <element: Identifier?> ")" => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Application: AST<'input> = {
    <function: Identifier> "(" <arguments: Arguments> ")" => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
            arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::FunctionApplication{function: Box::new(function), arguments: boxed_arguments}
    },
    <field: Field> "(" <arguments: Arguments> ")" => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
        arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::MethodCall{method_path: Box::new(field), arguments: boxed_arguments}
    },
    <array: ArrayAccess> "(" <arguments: Arguments> ")" => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
            arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::MethodCall{method_path: Box::new(array), arguments: boxed_arguments}
    }
}

Arguments: Vec<AST<'input>> = {
    <elements: (<Expression> ",")*> <element: Expression?> => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Assignment: AST<'input> = {
    "let" <id: Identifier> "=" <v: Expression> =>
        AST::Assignment{identifier: Box::new(id), value: Box::new(v)},
}

Mutation: AST<'input> = {
    <id: Identifier> "<-" <v: Expression> =>
        AST::Mutation{identifier: Box::new(id), value: Box::new(v)},
    <field: Field> "<-" <v: Expression> =>
        AST::FieldMutation{field_path: Box::new(field), value: Box::new(v)},
    <array: ArrayAccess> "<-" <v: Expression> =>
        AST::ArrayMutation {array: Box::new(array), value: Box::new(v)},
}

Identifier: AST<'input> = {
     r"[_A-Za-z][_A-Za-z0-9]*"           => AST::Identifier(<>),
     "this"                              => AST::Identifier(<>),
}

Number: AST<'input> = {
    r"[-]?[0-9]+"                        => AST::Number(i32::from_str(<>).unwrap()),
}

String: AST<'input> = {
    <s:r#""([^\\]|\\[ntbr\\])*""#>       => AST::StringLiteral(&s[1..s.len()-1]),
}

Boolean: AST<'input> = {
    "true"                               => AST::Boolean(true),
    "false"                              => AST::Boolean(false),
}

Unit: AST<'input> = {
    "null"                               => AST::Unit,
}