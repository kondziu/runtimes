use std::str::FromStr;
use crate::fml_ast::AST;

grammar;

pub Expression: AST<'input> = {
    Expression_<"I">                       => <>,
}

Expression_<allow>: AST<'input> = {
    "(" <Expression> ")"                  => <>, // expression in parentheses
    Block                                 => <>, // expression block

    FunctionDefinition                    => <>, // Feeny-style function definition, returns unit?
    FunctionApplication                   => <>, // function application

                                                 // prototype object definition
                                                 // field access
                                                 // field mutation
                                                 // method call

                                                 // array definition (argument is array size and initial value
                                                 // array access
                                                 // array mutation

    Conditional<allow>                    => <>, // conditional expression
    Loop                                  => <>, // loop expression

    Assignment                            => <>, // Feenified variable definition
    Identifier                            => <>, // variable access
    Mutation                              => <>, // variable mutation

    //Print                               => <>, // call to the print built-in
    //Operation                           => <>, // infix operators, syntactic sugar to method calls

    Literal                               => <>,
}

Conditional<allow>: AST<'input> = {
    "if" <condition: Expression> "then" <consequent: Expression_<"">> <alternative: ("else" <Expression_<"I">>)> =>
        AST::Conditional{condition: Box::new(condition),
                         consequent: Box::new(consequent),
                         alternative: Box::new(alternative)},
//    "if" <condition: Expression> "then" <consequent: Expression_<"I">> if allow != "" =>
//        AST::Conditional{condition: Box::new(condition),
//                         consequent: Box::new(consequent),
//                         alternative: Box::new(AST::Unit)},
}

Loop: AST<'input> = {
    "while" <condition: Expression> "do" <body: Expression> =>
        AST::Loop{condition: Box::new(condition), body: Box::new(body)}
}

Block: AST<'input> = {
    "begin" <expressions: Expressions> "end" =>
        if expressions.is_empty() {
            AST::Unit
        } else {
            let boxed_expressions: Vec<Box<AST<'input>>> =
                    expressions.into_iter().map(|e| Box::new(e)).collect();
            AST::Block(boxed_expressions)
        }
}

Expressions: Vec<AST<'input>> = {
    <elements: (<Expression> ";")*> <element: Expression?> => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

FunctionDefinition: AST<'input> = {
    "function" <id: Identifier> <parameters: Parameters> "<-" <body: Expression> => {
        let boxed_parameters: Vec<Box<AST<'input>>> =
            parameters.into_iter().map(|e| Box::new(e)).collect();
        AST::FunctionDefinition{identifier: Box::new(id),
                                parameters: boxed_parameters,
                                body: Box::new(body)}
    }
}

Parameters: Vec<AST<'input>> = {
    "(" <elements: (<Identifier> ",")*> <element: Identifier?> ")" => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

FunctionApplication: AST<'input> = {
    <function: Identifier> <arguments: Arguments> => {
        let boxed_arguments: Vec<Box<AST<'input>>> =
            arguments.into_iter().map(|e| Box::new(e)).collect();
        AST::FunctionApplication{identifier: Box::new(function), arguments: boxed_arguments}
    }
}

Arguments: Vec<AST<'input>> = {
    "(" <elements: (<Expression> ",")*> <element: Expression?> ")" => match element {
        None => elements,
        Some(e) => { let mut elements = elements; elements.push(e); elements }
    }
}

Assignment: AST<'input> = {
    "let" <id: Identifier> "=" <v: Expression> =>
        AST::Assignment{identifier: Box::new(id), value: Box::new(v)},
}

Mutation: AST<'input> = {
    <id: Identifier> "<-" <v: Expression> =>
        AST::Mutation{identifier: Box::new(id), value: Box::new(v)},
}

Literal: AST<'input> = {
    Number                               => <>,
    String                               => <>,
    Boolean                              => <>,
    Unit                                 => <>,
}

Identifier: AST<'input> = {
     r"[_A-Za-z][_A-Za-z0-9]*"           => AST::Identifier(<>),
     "this"                              => AST::Identifier(<>),
}

Number: AST<'input> = {
    r"[-]?[0-9]+"                        => AST::Number(i32::from_str(<>).unwrap()),
}

String: AST<'input> = {
    <s:r#""([^\\]|\\[ntbr\\])*""#>       => AST::StringLiteral(&s[1..s.len()-1]),
}

Boolean: AST<'input> = {
    "true"                               => AST::BooleanLiteral(true),
    "false"                              => AST::BooleanLiteral(false),
}

Unit: AST<'input> = {
    "null"                               => AST::Unit,
}

//ExprOperation: AST<'input> = {
//    <left: Expression> <operator: Operator> <right: Expression> =>
//        AST::Operation{operator, left, right}
//}

//Tier<Operator, NextTier>: AST<'input> = {
//    Tier<Op, NextTier> <operator: Operator> NextTier => AST::Operation(operator, Box::new(AST::Unit), Box::new(AST::Unit)),
//    NextTier
//};

//Operator1: Operator = {
//    "+" => Operator::Plus,
//        "-" => Operator::Minus,
//}

//Operator2: Operator = {
//    "*" => Operator::Times,
//    "/" => Operator::Divide,
//}

//    "!=" => Operator::Unequal,
//    "=="  => Operator::Equal,
//    "<"  => Operator::Less,
//    ">"  => Operator::Greater,
//    ">=" => Operator::GreaterEqual,
//    "<=" => Operator::LessEqual,
//    "|"  => Operator::Or,
//    "&"  => Operator::And,